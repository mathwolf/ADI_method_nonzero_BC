function tester()
%UNTITLED Summary of this function goes here
%   Detailed explanation goes here

TRUE = 1;
FALSE = 0;

% Constants used to switch between different test functions.
EXPONENT_1 = 1;
EXPONENT_2 = 2;
TRIG = 3;
POLYNOMIAL = 4;
global test_solution
test_solution = EXPONENT_1;

% Constants used to switch between different test domains.
CIRCLE = 1;
ELLIPSE = 2;
DIAMOND = 3;
ELL = 4;
RECTANGLE = 5;
DIAMOND_2 = 6;
global domain
domain = RECTANGLE;

% Description of spatial grid.  We divide both the x and y dimensions of
% the problem into the same number of gridpoints.  First, identify the min 
% and max values in both directions.  The actual domain of the PDE will be 
% a subset of the big rectangle defined by these values.

% For now, we are just defaulting to a cube of side length 2.
if domain == ELLIPSE
   x_min = -1;
   x_max = 1;
   y_min = -0.5;
   y_max = 0.5;
elseif domain == RECTANGLE
   x_min = -1;
   x_max = 1;
   y_min = -0.5;
   y_max = 0.5;    
elseif domain == DIAMOND_2
   x_min = -1;
   x_max = 0.5;
   y_min = -1;
   y_max = 0.5;    
else
    % all the other test domains have the same spatial range
   x_min = -1;
   x_max = 1;
   y_min = -1;
   y_max = 1;
   z_min = -1;
   z_max = 1;
end

N = 5;
hx = (x_max - x_min)/N;
hy = (y_max - y_min)/N;
hz = (z_max - z_min)/N;

% Define the gridpoints that are part of the interior of the domain of the
% PDE.  Check each gridpoint in the array to see if it is an interior 
% point.  Examine one stack at a time beginning with the leftmost column
% and uppermost row.
for i = 1:N-1
   for j = 1:N-1
       for k = 1:N-1
           x = x_min + hx * i;
           y = y_min + hy * j;
           z = z_min + hz * k;
           if (phi1(x) < y) && (y < phi2(x)) && ...
                    (zeta1(x,y) < z) && (z < zeta2(x,y))
               % The point is an interior point
               grid(i,j,k).on = TRUE; 
               grid(i,j,k).x = x;
               grid(i,j,k).y = y;
               grid(i,j,k).z = z;
               grid(i,j,k).U = g3(x,y,z);   % use initial condition to fill in the
                                            % value of the approximation
               grid(i,j).V = 0.;            % grid function for partial timesteps
           else
               % The point is an exterior point
               grid(i,j).on = FALSE;
           end
       end
   end
end


end

